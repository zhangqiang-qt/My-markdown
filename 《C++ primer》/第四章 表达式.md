### 4.1 基础
#### 4.1.1 基本概念
##### 运算对象转换
&emsp;&emsp;小整数类型(如 bool、char、short等)通常会被**提升**为较大的整数类型，主要是 int。
##### 重载运算符
&emsp;&emsp;运算符作用于类类型的运算对象时，用户可以自定义其含义。这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，称为**重载运算符**。
##### 左值和右值
&emsp;&emsp;当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的位置)。

- 赋值运算符需要一个(非常量)左值作为其左侧运算对象，得到的结果仍然是一个左值。
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是个右值。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string 和 vector 的下标运算符的求值结果都是左值。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。

#### 4.1.3 求值顺序
&emsp;&emsp;有四种运算符明确规定了运算对象的求值顺序。**逻辑与(&&)运算符**规定先求左侧运算对象的值，当左侧运算对象的值为真时才继续求右侧运算对象的值。另外三种分别是**逻辑或(||)运算符**、**条件(?:)运算符**和**逗号(,)运算符**。

&emsp;&emsp;**Note**：拿不准的时候用括号强制让表达式的组合关系符合程序逻辑的要求；如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象(当改变运算对象的子表达式本身是另外一个字表达式的运算对象时该规则无效，如 *++iter)。

### 4.2 算术运算符
&emsp;&emsp;一元运算符(一元正、负号)的优先级最高，其次是乘法和除法，最后是加法和减法。上述运算符均满足左结合律。

&emsp;&emsp;算术运算符的运算对象和求值结果都是右值。

&emsp;&emsp;当计算的结果超出该类型所能表示的范围时就会产生**溢出**。

&emsp;&emsp;参与**取余**运算的运算对象必须是整数类型。如果 m % n 不等于 0，则其符号与 m 相同，即 m % (-n) 等于 m % n，(-m) % n 等于 -(m % n)。

&emsp;&emsp;在**除法**运算中，商一律向 0 取整，即直接切除小数部分。

### 4.3 逻辑和关系运算符
&emsp;&emsp;逻辑运算符作用于任意能转换成布尔值的类型，关系运算符作用于算术类型或指针类型，两者的运算对象和求值结果均为右值，返回值均为布尔类型。

##### 逻辑与和逻辑或运算符
&emsp;&emsp;**短路求值**：使用逻辑与运算符(&&)时，当且仅当左侧运算对象为真时才对右侧与运算对象求值；使用逻辑或运算符(||)时，当且仅当左侧运算对象为假时才对右侧运算对象求值。

### 4.4 赋值运算符
&emsp;&emsp;赋值运算符的左侧运算对象必须是一个可修改的左值。赋值运算的结果是它的左侧运算对象，并且是一个左值。

&emsp;&emsp;赋值运算符满足右结合律。

### 4.5 递增和递减运算符
&emsp;&emsp;这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回。

&emsp;&emsp;**Suggestion**：除非必须，否则不用递增递减运算符的后置版本。

&emsp;&emsp;后置递增运算的优先级高于解引用运算符，如 *p++ 等价于 *(p++)。

### 4.6 成员访问运算符
&emsp;&emsp;点运算符和箭头运算符都可用于访问成员，点运算符获取类对象的一个成员，箭头运算符与点运算符有关。表达式 ptr -> mem 等价于 (*ptr).mem (点运算符的优先级高于解引用运算符)。

### 4.7 条件运算符
```cpp
cond ? expr1 : expr2;
```
&emsp;&emsp;cond 是判断条件的表达式，expr1 和 expr2 是两个类型相同或可能转换为某个公共类型的表达式。首先求 cond 的值，条件为真则对 expr1 求值并返回该值，否则对 expr2 求值并返回该值。

&emsp;&emsp;当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则运算的结果是右值。

&emsp;&emsp;条件运算符满足右结合律。
### 4.8 位运算符
&emsp;&emsp;位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。

&emsp;&emsp;**左移运算符**(<<)在右侧插入值为 0 的二进制位，对于**右移运算符**(>>)：若其左侧运算对象是无符号类型，在左侧插入值为 0 的二进制位，否则在左侧插入符号位的副本或值为 0 的二进制位。移位运算符++满足左结合律++，其优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高。

&emsp;&emsp;**位求反运算符**(~)将运算对象逐位求反；**位与运算符**(&)，两个运算对象的对应位置均为 1 时结果中该位为 1，否则为 0；**位或运算符**(|)，两个运算对象的对应位置至少有一个为 1 时结果中该位为 1，否则为 0；**位异或运算符**(^)，两个运算对象的对应位置有且仅有一个为 1 时结果中该位为 1，否则为 0。记忆秘诀：位与有 0 则 0；位或有 1 则 1；异或不同为 1，相同为 0。

### 4.9 sizeof 运算符
&emsp;&emsp;sizeof 运算符返回一条表达式或一个类型名字所占的字节数，满足右结合律，其所得的值是一个 size_t 类型的常量表达式。

&emsp;&emsp;C++ 内置数组没有定义成员函数 size()，无法直接得到数组的容量。而执行 ++sizeof 运算能得到整个数组的大小++，所以**可以用数组的大小除以单个元素的大小得到数组中元素的个数**。
```cpp
constexpr size_t sz = sizeof(ia) / sizeof(*ia);
int arr[sz];
```
### 4.10 逗号运算符
&emsp;&emsp;**逗号运算符**含有两个运算对象，按照从左向右的顺序依次求值，其真正的结果是右侧表达式的值。

### 4.11 类型转换
&emsp;&emsp;如果两种类型可以相互转换，那么它们就是关联的。
##### 何时发生隐式转换
- 多数表达式中比 int 类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔类型转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 若算术运算或关系运算的运算对象有多种类型，需要转换成同一类型。
- 函数调用时也会发生类型转换。

#### 4.11.1 算术转换

##### 整型提升
&emsp;&emsp;**整型提升**负责把小整数类型转换成较大的整数类型。

&emsp;&emsp;如果一个运算对象是无符号类型，另外一个对象是带符号类型，且**无符号类型不小于带符号类型**，那么带符号的运算对象转换成无符号的；若**带符号类型大于无符号类型**，转换的结果依赖于机器，即无符号类型的所有值都能存在该带类型符号中，则无符号类型转换成该带符号类型，否则带符号类型转换成无符号类型。

#### 4.11.3 显示转换
##### 命名的强制类型转换
```cpp
cast-name<type>(expression);
```
&emsp;&emsp;type 是转换的目标类型，expression 是要转换的值。若 type 是引用类型，则结果是左值。cast_name 包括 **static_cast**、**dynamic_cast**、**const_cast**、**reinterpret_cast**。

&emsp;&emsp;**Note**：避免强制类型转换。

#### 练习
[第四章部分习题代码](https://github.com/zhangqiang-qt/Cpp-primer/tree/master/%E7%AC%AC%E5%9B%9B%E7%AB%A0)
