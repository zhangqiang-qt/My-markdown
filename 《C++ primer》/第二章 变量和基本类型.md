&emsp;&emsp;数据类型决定了程序中数据和操作的意义。

## 2.1　基本内置类型
&emsp;&emsp;算术类型包含了字符、整数型、布尔值和浮点数。

### 2.1.1 算术类型
&emsp;&emsp;算术类型分为两类：**整型**(包括字符和布尔类型)、**浮点型**。算术类型的尺寸在不同的机器上有所差别。

类型 | 含义 | 最小尺寸
---|---|---
bool | 布尔类型 | 未定义
char | 字符 | 8位
wchar_t | 宽字符 | 16位
char16_t | Unicode字符 | 16位
char32_t | Unicode字符 | 32位
short | 短整型 | 16位
int | 整型 | 16位
long | 长整型 | 32位
long long |长整型 | 64位
float | 单精度浮点数 | 6位有效数字
double | 双精度浮点数 | 10位有效数字
long double | 扩展精度浮点数 | 10位有效数字

- 一个 char 的大小和一个机器字节一样。wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符。

- 一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。

- 通常，float 以1个字(32bit)来表示，double 以2个字来表示，long double 以3或4个字来表示。

##### 带符号类型和无符号类型
&emsp;&emsp;除布尔类型和扩展的字符型外，其他整型可划分为**带符号**和**无符号**两种。通过在带符号的类型名前添加 unsigned 就可得到无符号类型。unsigned int 可简写为 unsigned。

&emsp;&emsp;字符型有三种：char、signed char、unsigned char，其表现形式依旧为带符号的和无符号的。char 的具体表现由编译器决定。

**Note**：类型选择的经验准则：

- 数值非负，选用无符号类型。
- 使用 int 执行整数运算。若数值超过 int 的表示范围，选用 long long。
- 在存放字符或布尔值时使用 char 或 bool ，在算术表达式中不要使用。
- 执行浮点数运算选用 double。因为 float 通常精度不够且双精度浮点数和单精度浮点数的计算代价相差无几。

### 2.1.2 类型转换
类型所能表示的值的范围决定了转换的过程：

- 非布尔类型的算术值赋给布尔类型，初始值为0则为 false，否则结果为 true。
- 布尔值赋给非布尔类型，初始值 false 则结果为0，true 为1。
- 浮点数赋给整数类型，结果保留小数点之前的部分。
- 整数值赋给浮点类型，小数部分记为0。
- 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。如将-1赋给 8bit 大小的 unsigned char(表示0-255区间内的值)，那么-1对256取模即-1 % 256 = -1，补码为100000001，原码为011111111，即结果为255。
- 赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**。

##### 含有无符号类型的表达式
&emsp;&emsp;若表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，因为带符号数会自动转换成无符号数。**把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模**。

```cpp
int a = -1;
unsigned b = 1;
cout << a * b << endl;
/*
*输出结果
*4294967295
*/
```
&emsp;&emsp;a 为 int 类型(32bit)且 a = -1，b 为 unsigned 类型且 b = 1。计算 a * b 时，带符号的 a 自动转换为无符号数，此时-1转换的无符号数为其原码对应的十进制数，即2^32 - 1 = 4294967295。
### 2.1.3 字面值常量
&emsp;&emsp;每个字面值常量都对应一种数据类型，字面值常量的形式和值决定它的数据类型。

##### 整型和浮点型字面值
&emsp;&emsp;整型字面值可写作十进制数、八进制数(以0开头的整数)或十六进制数(以0x或0X开头的整数)，具体数据类型由值和符号决定。类型 short 没有对应的字面值。

&emsp;&emsp;浮点型字面值表现为一个小数或以科学计数法表示的指数(E或e标识)。浮点型字面值默认为 double 类型。

##### 字符和字符串字面值
&emsp;&emsp;char型字面值：单引号括起来的一个字符。

&emsp;&emsp;字符串字面值：双引号括起来的零个或多个字符，其类型实际上是由常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符('\0')，故字符串字面值的实际长度比内容多1。

##### 转义序列

操作 | 转义序列
---|---
换行符 | \n
纵向制表符 | \v
横向制表符 | \t
反斜线 | \\\
回车符 | \r
退格符 | \b
问号 | \\?
进纸符 | \f
报警符 | \a
双引号 | \\"
单引号 | \\'

&emsp;&emsp;泛化的转义序列：\x后紧跟1个或多个十六进制数字，或\后紧跟1、2或3个(不能超过3个)八进制数字，数字部分表示字符对应的数值。
##### 指定字面值的类型

前缀 | 类型
---|---
u | char16_t
U | char32_t
L | wchar_t
u8 | char

后缀 | 类型
---|---
u、U | unsigned
l、L | long
ll、LL | long long
f、F | float
l、L | long double

##### 布尔字面值和指针字面值
&emsp;&emsp;布尔字面值：true、false。

&emsp;&emsp;指针字面值：nullptr。

## 2.2 变量
&emsp;&emsp;**变量**提供一个具名的、可供程序操作的存储空间。

&emsp;&emsp;**对象**指一块能存储数据并具有某种类型的内存空间。

&emsp;&emsp;**初始化**的含义是创建变量时赋予其一个初始值；**赋值**的含义是把对象的当前值擦除，再用一个新值来替代。

##### 列表初始化
&emsp;&emsp;定义一个名为 units_sold 的 int 变量并初始化为0，以下4条语句均可：
```cpp
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```
&emsp;&emsp;这种以花括号来初始化变量的形式称为**列表初始化**。若使用列表初始化且初始值存在信息丢失的风险，则编译器将报错。
##### 默认初始化
&emsp;&emsp;若定义变量时没有指定初值，则变量被**默认初始化**。内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。

&emsp;&emsp;定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式初始化，其值由类确定。

### 2.2.2 变量声明和定义的关系
&emsp;&emsp;**声明**使得名字为程序所知，一个文件使用别处定义的名字必须包含对那个名字的声明。一条声明语句由一个**基本数据类型**和紧随其后的一个**声明符**列表组成。

&emsp;&emsp;**定义**负责创建与名字关联的实体。变量声明规定了变量的类型和名字，定义还申请存储空间，也可能为变量赋初始值。

&emsp;&emsp;声明一个变量而非定义，要在变量名前添加关键字 extern 且不能显式初始化变量。任何包含了显式初始化的声明即为定义。
```cpp
extern int i; //声明而非定义i
int j;        //声明且定义j
extern double pi = 3.1416; //定义
```
&emsp;&emsp;变量只能被定义一次，但可以多次声明。如果要在多个文件中使用同一变量，必须将声明和定义分离。变量的定义必须且只能出现在一个文件中，其他用到该变量的文件必须声明该变量且不能重复定义。

&emsp;&emsp;**静态类型**：在编译阶段检查类型。
### 2.2.3 标识符
&emsp;&emsp;C++的**标识符**由字母、数字和下划线组成，必须以字母或下划线开头。用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。
##### 变量命名规范
- 标识符要能体现实际含义。
- 变量名一般用小写字母。
- 用户自定义的类名一般以大写字母开头。
- 标识符由多个单词组成，单词之间应有明显区分。

### 2.2.4 名字的作用域
&emsp;&emsp;同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

&emsp;&emsp;**全局作用域**内的名字在整个程序的范围内都可使用。与之对应，**块作用域**的名字在相应的程序块内可使用。

&emsp;&emsp;**Note**：第一次使用变量时再定义该变量。

##### 嵌套的作用域
&emsp;&emsp;**内层作用域**：被包含的作用域。

&emsp;&emsp;**外层作用域**：包含其他作用域的作用域。

## 2.3 复合类型
### 2.3.1 引用
&emsp;&emsp;**引用**为对象起了**别名**，通过将声明符写成 &name 的形式来定义引用类型。
```cpp
int ival = 1024;
int &name = ival;
```
&emsp;&emsp;**引用必须被初始化，且初始值必须为一个对象**。一旦初始化完成，引用就和其初始值对象一直绑定在一起，对引用进行的所有操作都是在与之绑定的对象上进行的(即对引用进行的一切操作，均作用在该引用绑定的对象上)。

&emsp;&emsp;**Note**：引用本身不是一个对象，不能定义引用的引用。而且引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。
## 2.3.2 指针
&emsp;&emsp;指针与引用的**相同点**：均实现了对其他对象的间接访问。**不同点**：1.指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。2.指针无须在定义时赋初值。

&emsp;&emsp;定义指针类型的方法是将声明符写成 *name 的形式，name 是变量名。指针存放某个对象的地址，使用取地址符 & 获取地址。
```cpp
int ival = 42;
int *name = &ival;
```
&emsp;&emsp;引用不是对象，没有实际地址，不能定义指向引用的指针。
##### 指针值
指针的值(地址)应属下列四种状态之一：

- 指向一个对象。
- 指向紧邻对象所占空间的下一个位置。
- 空指针，即指针没有指向任何对象。
- 无效指针。

##### 利用指针访问对象
&emsp;&emsp;使用**解引用符**(*)访问指针指向的对象。那么，给解引用的结果赋值，等同于给指针所指的对象赋值。

```cpp
cout << *name; //输出42
*name = 1;
cout << *name; //输出1
```
##### 空指针
&emsp;&emsp;**空指针**不指向任何对象。

```cpp
int *p1 = nullptr;
int *p2 = 0;
//#include <cstdlib>
int *p3 = NULL;
```
&emsp;&emsp;**Note**：初始化所有指针。给指针赋值即存放新的地址，指向一个新的对象。赋值永远改变的是等号左侧的对象。
##### void* 指针
&emsp;&emsp;**void*** 可用于存放任意对象的地址，但不能直接操作其所指的对象。
### 2.3.3 复合类型的声明
##### 指向指针的指针

```
graph LR
ppi-->pi
pi-->ival=1024
```
```cpp
int ival = 1024;
int *pi = &ival;
int **ppi = &pi;
cout << ival; //1024
cout << *pi;  //1024
cout << **ppi; //1024
```
##### 指向指针的引用
&emsp;&emsp;引用不是对象，没有实际地址，不能定义指向引用的指针。指针是对象，所以存在对指针的引用。
```cpp
int i = 42;
int *p;
int *&r = p; //r是对指针p的引用
r = &i;      //即 p = &i;
*r = 0;      //即 *p = 0;故 i 的值改为0
```
&emsp;&emsp;离变量名最近的符号对变量的类型有最直接的影响。

## 2.4 const限定符
&emsp;&emsp;**const对象被创建后其值就不能再改变**，所以 const 对象必须初始化。
```cpp
const int i = get_size();
const int j = 42;
const int k;    //错误，k未初始化
```
&emsp;&emsp;默认情况下，const 对象被设定为仅在文件内有效。多个文件中出现了同名的 const 变量时，等同于在不同文件中分别定义了独立的变量。

&emsp;&emsp;在多个文件之间共享 const 对象，必须在变量的定义之前添加 extern 关键字。

### 2.4.1 const 的引用
&emsp;&emsp;**对常量的引用**：将引用绑定到 const 对象上。
##### 初始化和对 const 的引用
&emsp;&emsp;引用的类型必须与其所引用的对象的类型一致。但是有两个例外：1.初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。

&emsp;&emsp;允许为一个常量引用绑定**非常量的对象、字面值，甚至一般表达式**。

```cpp
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2;
```
&emsp;&emsp;常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。
### 2.4.2 指针和 const
&emsp;&emsp;**指向常量的指针**不能用于改变其所指对象的值。指针的类型必须与其所指对象的类型一致。但是有两个例外：1.允许一个指向常量的指针指向一个非常量对象。
```cpp
double dval = 3.14;
const double *cptr = &dval;
```
&emsp;&emsp;指向常量的指针也没有规定其所指的对象必须是一个常量，且仅要求不能通过该指针改变对象的值，没有规定该对象的值不能通过其他途径改变。
##### const 指针
&emsp;&emsp;**常量指针必须初始化**。一旦初始化完成，其值(即存放在指针中的地址)不能改变。
```cpp
int num = 0;
int *const cur = &num;          //cur 一直指向 num
const double pi = 3.14;
const double *const pip = &pi;  //pip 是一个指向常量对象的常量指针
```
&emsp;&emsp;常量指针不能被赋值，即不能单独进行 pip = pi 或 pip = &pi 的操作。

### 2.4.3 顶层 const
&emsp;&emsp;**顶层 const**表示*指针本身是个常量*，**底层 const**表示*指针所指的对象是个常量*。更一般的，顶层 const 可以表示++任意的对象是常量++，对任何数据类型都适用；底层 const 与指针和引用等复合类型的基本类型部分有关。指针类型既可以是顶层 const 也可以是底层 const。
```cpp
int i = 0;
int *const p1 = &i;         //p1 一直指向 i，顶层 const
const int ci = 42;          //ci 的值不能修改，顶层 const
const int *p2 = &ci;        //允许改变 p2 的值，底层 const
const int *const p3 = p2;   //第一个为底层 const，第二个为顶层 const
const int &r = ci;          //用于声明引用的 const 均为底层 const
```
&emsp;&emsp;执行对象的拷贝操作时，不会改变被拷贝对象的值，顶层 const 不受影响，但拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般，非常量可以转换为常量，反之不行。

### 2.4.4 constexpr 和常量表达式(高级主题)
&emsp;&emsp;**常量表达式**指值不会改变且在编译过程就能得到计算结果的表达式，包括字面值、用常量表达式初始化的 const 对象(由数据类型和初始值共同决定)。
##### constexpr
&emsp;&emsp;允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式。

&emsp;&emsp;声明为 constexpr 的变量一定是一个常量，而且必须用过常量表达式初始化。
```cpp
constexpr int mf = 20;         //20是常量表达式
constexpr int limit = mf + 1;  //mf + 1 是常量表达式
constexpr int sz = size();     //size要为 constexpr 函数
```
##### 字面值类型
&emsp;&emsp;声明 constexpr 时用到的类型为**字面值类型**，包括算术类型、引用和指针。constexpr 指针的初始值必须是 nullptr 或 0，或者是存储于某个++固定地址中的对象++(定义与所有函数体之外的对象，有效范围超出函数本身的变量)。
##### 指针和 constexpr
&emsp;&emsp;若在 constexpr 声明中定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。
```cpp
const int *p = nullptr;     //p是指向整型常量的指针
constexpr int *q = nullptr; //q是指向整数的常量指针
```
&emsp;&emsp;constexpr 将其所定义的对象置为了顶层 const。

## 2.5 处理类型
### 2.5.1 类型别名
&emsp;&emsp;**类型别名**是一个名字，是某种类型的同义词。定义类型别名有两种方法，其一是关键字 **typedef**：
```cpp
typedef double wages;
```
其二是使用**别名声明**：
```cpp
using SI = Sales_item;
```
&emsp;&emsp;含 typedef 的声明语句定义的不再是变量而是类型别名。

### 2.5.2 auto 类型说明符
&emsp;&emsp;**auto** 让编译器通过初始值来推算变量的类型，因此 auto 定义的变量必须有初始值。
##### 复合类型、常量和 auto
&emsp;&emsp;使用引用即使用引用的对象。当引用被用作初始值时，参与初始化的是引用对象的值。编译器以引用对象的类型作为 auto 的类型。
```cpp
int i = 0, &r = i;
auto a = r; //a 的类型为 int
```
&emsp;&emsp;auto 一般忽略顶层 const，同时保留底层 const。
```cpp
const int ci = i, &cr = ci; //ci 为顶层 const
auto b = ci;                //b 为 int
auto c = cr;                //c 为 int
auto d = &i;                //d 为整型指针
auto e = &ci;               //e为一个指向整数常量的指针
```
&emsp;&emsp;**Note**：整数的地址就是指向整数的指针(d)。对常量对象取地址是一种底层 const (e)。

&emsp;&emsp;若希望推断出的 auto 类型是一个顶层 const，需要明确指出。
```cpp
const auto f = ci;
```
&emsp;&emsp;可将引用的类型设为 auto。
```cpp
auto &g = ci;       //g为整型常量引用，绑定到ci
auto &h = 42;       //错误，不能为非常量引用绑定字面值
const auto &j = 42; //正确，可以为常量引用绑定字面值
```
### 2.5.3 decltype 类型指示符
&emsp;&emsp;decltype 的作用是选择并返回操作数的数据类型。编译器分析表达式并得到其类型，不实际计算表达式的值。

&emsp;&emsp;decltype 处理顶层 const和引用的方式和 auto 不同。若 decltype 使用的表达式是一个变量，则返回该变量的类型(包括顶层 const 和引用在内)。

##### decltype 和引用
&emsp;&emsp;若 decltype 使用的表达式不是一个变量，则返回表达式结果对应的类型。如果表达式的内容是解引用(*)操作，则 decltype 将得到引用类型。

&emsp;&emsp;decltype 与 auto 的另一处不同在于：decltype 的结果类型与表达式形式密切相关。如果 decltype 使用的是一个不加括号的变量，则得到的结果为该变量的类型；如果给变量加上一层或多层括号，编译器将其看作表达式，**decltype 的表达式如果是加上了括号的变量，结果为引用**。
```cpp
int i = 5;
decltype((i)) d; //d 为 int&，且必须初始化
decltype(i) e;   //e 是一个 int
```
&emsp;&emsp;赋值也是会产生引用的一类表达式，引用的类型是左值的类型。若 i 为 int，那么表达式 i = j 的类型就是 int&。

### 2.6.3 编写自己的头文件
&emsp;&emsp;为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应该与类的名字相同。

&emsp;&emsp;头文件通常包含那些只能被定义一次的实体，如类、const 和 constexpr 变量等。
##### 预处理器概述
&emsp;&emsp;确保头文件多次包含仍能安全工作的常用技术是**预处理器**。当预处理器看到 #inlcude 标记时就会用指定的头文件的内容代替 #include。

&emsp;&emsp;**#define** 指令把一个名字设定为预处理变量。

&emsp;&emsp;**#ifdef** 当且仅当变量已定义时为真，**#ifndef** 当且仅当变量未定义时为真。一旦检测结果为真，则执行后续操作直至遇到 **#endif** 指令为止。
```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
...
#endif
```
&emsp;&emsp;一般把预处理变量的名字全部大写。

### 练习题
[第二章部分练习题代码](https://github.com/zhangqiang-qt/Cpp-primer)
